'use strict';

var reduxSaga_utils = require('redux-saga/utils');
var ramdasauce = require('ramdasauce');
var ramda = require('ramda');

// effect names
var TAKE = 'TAKE';
var PUT = 'PUT';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var RACE = 'RACE';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var PARALLEL = 'PARALLEL';
var ITERATOR = 'ITERATOR';
var PROMISE = 'PROMISE'; // not from redux-saga
var UNKNOWN = 'UNKNOWN'; // not from redux-saga

// monitoring statuses
var PENDING = 'PENDING';
var RESOLVED = 'RESOLVED';
var REJECTED = 'REJECTED';
var CANCELLED = 'CANCELLED';

var getEffectName = (function (effect) {
  if (!effect) return UNKNOWN;
  if (effect instanceof Promise) return PROMISE;
  if (reduxSaga_utils.asEffect.take(effect)) return TAKE;
  if (reduxSaga_utils.asEffect.put(effect)) return PUT;
  if (reduxSaga_utils.asEffect.call(effect)) return CALL;
  if (reduxSaga_utils.asEffect.cps(effect)) return CPS;
  if (reduxSaga_utils.asEffect.fork(effect)) return FORK;
  if (reduxSaga_utils.asEffect.join(effect)) return JOIN;
  if (reduxSaga_utils.asEffect.race(effect)) return RACE;
  if (reduxSaga_utils.asEffect.cancel(effect)) return CANCEL;
  if (reduxSaga_utils.asEffect.select(effect)) return SELECT;
  if (reduxSaga_utils.is.array(effect)) return PARALLEL;
  if (reduxSaga_utils.is.iterator(effect)) return ITERATOR;
  return UNKNOWN;
});

// Provides an additional description of the effect.  A friendlier name
// to display to the humans.
/* eslint-disable no-cond-assign */
var getEffectDescription = (function (effect) {
  if (!effect) return UNKNOWN;
  if (effect instanceof Promise) {
    var display = void 0;
    if (effect.name) {
      // a promise object with a manually set name prop for display reasons
      display = PROMISE + '(' + effect.name + ')';
    } else if (effect.constructor instanceof Promise.constructor) {
      // an anonymous promise
      display = PROMISE;
    } else {
      // class which extends Promise, so output the name of the class to precise
      display = PROMISE + '(' + effect.constructor.name + ')';
    }
    return display;
  }
  if (effect.root) return effect.saga.name;
  var data = void 0;
  if (data = reduxSaga_utils.asEffect.take(effect)) return data.pattern || 'channel';
  if (data = reduxSaga_utils.asEffect.put(effect)) return data.channel ? data.action : data.action.type;
  if (data = reduxSaga_utils.asEffect.call(effect)) {
    return ramdasauce.isNilOrEmpty(data.fn.name) ? '(anonymous)' : data.fn.name;
  }
  if (data = reduxSaga_utils.asEffect.cps(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.fork(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.join(effect)) return data.name;
  if (reduxSaga_utils.asEffect.race(effect)) return null;
  if (data = reduxSaga_utils.asEffect.cancel(effect)) return data.name;
  if (data = reduxSaga_utils.asEffect.select(effect)) return data.selector.name;
  if (reduxSaga_utils.is.array(effect)) return null;
  if (reduxSaga_utils.is.iterator(effect)) return effect.name;
  return UNKNOWN;
});

// import { reject, values, pluck, isNil, split, pathOr, last, forEach, propEq, filter, __, map, omit } from 'ramda'

// creates a saga monitor
var _createSagaMonitor = (function (reactotron, options) {
  // a lookup table of effects - keys are numbers, values are objects
  var effects = {};

  // filtering that effect table
  var byParentId = ramda.propEq('parentEffectId', ramda.__);
  var byLabel = ramda.propEq('label', ramda.__);
  var getChildEffectInfos = function getChildEffectInfos(parentEffectId) {
    return ramda.filter(byParentId(parentEffectId), ramda.values(effects));
  };
  var getChildEffectIds = function getChildEffectIds(effectId) {
    return ramda.pluck('effectId', getChildEffectInfos(effectId));
  };

  // start a relative timer
  var timer = reactotron.startTimer();

  // ---------------- Sending Effect Updates ----------------
  // const sendReactotronEffectTree = () => reactotron.send('saga.effect.update', effects)

  // ---------------- Starting -----------------------------

  // redux-saga calls this when an effect is triggered (started)
  var effectTriggered = function effectTriggered(description) {
    var effect = description.effect,
        effectId = description.effectId,
        parentEffectId = description.parentEffectId,
        label = description.label;

    // create an EffectInfo to hold the details

    var effectInfo = {
      effectId: effectId,
      parentEffectId: parentEffectId,
      effect: effect,
      label: label,
      status: PENDING,
      name: getEffectName(effect),
      description: getEffectDescription(effect),
      result: null,
      startedAt: timer()
    };

    // store it
    effects[effectId] = effectInfo;

    // send it
    // sendReactotronEffectTree()
  };

  // ---------------- Finishing ----------------------------

  // update the duration of the effect
  var updateDuration = function updateDuration(effectInfo) {
    effectInfo.duration = timer() - effectInfo.startedAt;
  };

  // fires when a task has been resolved
  var taskResolved = function taskResolved(effectId, taskResult) {
    // lookup this effect info
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    var duration = effectInfo.duration;

    // grab the parent too

    var parentEffectId = effectInfo.parentEffectId;

    var parentEffectInfo = effects[parentEffectId];
    var children = [];

    // a human friendly name of the saga task
    var sagaDescription = void 0;
    // what caused the trigger
    var triggerType = void 0;

    // for FORK tasks, we have a bunch on things to pass along
    if (effectInfo.name === FORK) {
      var args = ramda.pathOr([], ramda.split('.', 'effect.FORK.args'), effectInfo);
      var lastArg = ramda.last(args);
      triggerType = lastArg && lastArg.type;
      if (parentEffectInfo) {
        if (parentEffectInfo.name === ITERATOR) {
          sagaDescription = parentEffectInfo.description;
        }
      } else {
        sagaDescription = '(root)';
        triggerType = effectInfo.description + '()';
      }

      // flatten out the nested effects
      var buildChild = function buildChild(depth, effectId) {
        var sourceEffectInfo = effects[effectId];
        if (ramda.isNil(sourceEffectInfo)) return;

        var extra = null;
        switch (sourceEffectInfo.name) {
          case CALL:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name].args;
            break;

          case PUT:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name].action;
            break;

          // children handle this
          case RACE:
            break;

          // TODO: More of customizations needed here

          default:
            extra = sourceEffectInfo.effect[sourceEffectInfo.name];
            break;
        }
        // assemble the structure
        children.push({
          depth: depth,
          effectId: sourceEffectInfo.effectId,
          parentEffectId: sourceEffectInfo.parentEffectId || null,
          name: sourceEffectInfo.name || null,
          description: sourceEffectInfo.description || null,
          duration: Math.round(sourceEffectInfo.duration),
          status: sourceEffectInfo.status || null,
          winner: sourceEffectInfo.winner || null,
          loser: sourceEffectInfo.loser || null,
          result: sourceEffectInfo.result || null,
          extra: extra || null
        });

        // rerun this function for our children
        ramda.forEach(function (x) {
          return buildChild(depth + 1, x);
        }, getChildEffectIds(effectId));
      };
      var xs = getChildEffectIds(effectId);
      ramda.forEach(function (effectId) {
        return buildChild(0, effectId);
      }, xs);
    }

    reactotron.send('saga.task.complete', {
      triggerType: triggerType || effectInfo.description,
      description: sagaDescription,
      duration: Math.round(duration),
      children: children
    });

    // effects = omit(map(String, pluck('effectId', children)), effects)
  };

  // redux-saga calls this when an effect is resolved (successfully or not)
  var effectResolved = function effectResolved(effectId, result) {
    // lookup this effect info and set the rsult
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.result = result;

    // this is a task
    if (reduxSaga_utils.is.task(result)) {
      // when the task promise resolves,
      var onTaskResult = function onTaskResult(taskResult) {
        if (result.isCancelled()) {
          effectCancelled(effectId);
        } else {
          effectResolved(effectId, taskResult);
          taskResolved(effectId, taskResult);
        }
      };

      // hook the promise to capture the resolve or reject
      result.done.then(onTaskResult, function (error) {
        effectRejected(effectId, error);
        if (!error.reactotronWasHere) {
          reactotron.reportError(error);
        }
        error.reactotronWasHere = true;
      });
    } else {
      // this is an effect and we are complete
      effectInfo.status = RESOLVED;
      effectInfo.result = result;
      if (effectInfo.name === RACE) {
        setRaceWinner(effectId, result);
      }
    }

    // send it
    // sendReactotronEffectTree()
  };

  // flags on of the children as the winner
  var setRaceWinner = function setRaceWinner(effectId, resultOrError) {
    var winnerLabel = Object.keys(resultOrError)[0];
    var children = getChildEffectInfos(effectId);
    var winningChildren = ramda.filter(byLabel(winnerLabel), children);
    var losingChildren = ramda.reject(byLabel(winnerLabel), children);
    var setWinner = function setWinner(effectInfo) {
      effectInfo.winner = true;
    };
    var setLoser = function setLoser(effectInfo) {
      effectInfo.loser = true;
    };

    // set the 1 (hopefully 1) winner -- but i'm not sure
    ramda.forEach(setWinner, winningChildren);
    ramda.forEach(setLoser, losingChildren);
  };

  // ---------------- Failing ------------------------------

  // redux-saga calls this when an effect is rejected (an error has happened)
  var effectRejected = function effectRejected(effectId, error) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = REJECTED;
    effectInfo.error = error;
    if (effectInfo.name === RACE) {
      setRaceWinner(effectId, error);
    }

    // send it
    // sendReactotronEffectTree()
  };

  // ---------------- Cancelling ---------------------------

  // redux-saga calls this when an effect is cancelled
  var effectCancelled = function effectCancelled(effectId) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = CANCELLED;

    // send it
    // sendReactotronEffectTree()
  };

  // the interface for becoming a redux-saga monitor
  return {
    effectTriggered: effectTriggered,
    effectResolved: effectResolved,
    effectRejected: effectRejected,
    effectCancelled: effectCancelled,
    actionDispatched: function actionDispatched() {}
  };
});

// Behold!  The entry point of our plugin
var plugin$1 = (function (pluginConfig) {
  return function (reactotron) {
    return {
      // make these functions available on the Reactotron
      features: {
        // spawn a saga monitor with the given options
        createSagaMonitor: function createSagaMonitor(options) {
          return _createSagaMonitor(reactotron, options);
        }
      }
    };
  };
});

module.exports = plugin$1;
